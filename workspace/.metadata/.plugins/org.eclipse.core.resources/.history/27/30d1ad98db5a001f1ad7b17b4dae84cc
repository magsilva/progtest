package progtest.evaluation;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Date;

import progtest.common.Evaluation;
import progtest.database.EvaluationDAO;
import progtest.exceptions.EvaluationException;
import progtest.reports.XMLParser;
import progtest.util.DirControl;
import progtest.util.Math;

public class Evaluator {

	private static double coveragePinstTinstFuncional;

	private static double coveragePalTalFuncional;

	private static double coveragePinstTalFuncional;

	private static double coveragePalTinstFuncional;

	private static double coveragePinstTinstAllNodes;

	private static double coveragePalTalAllNodes;

	private static double coveragePinstTalAllNodes;

	private static double coveragePalTinstAllNodes;

	private static double coveragePinstTinstAllEdges;

	private static double coveragePalTalAllEdges;

	private static double coveragePinstTalAllEdges;

	private static double coveragePalTinstAllEdges;

	private static double coveragePinstTinstAllUses;

	private static double coveragePalTalAllUses;

	private static double coveragePinstTalAllUses;

	private static double coveragePalTinstAllUses;

	private static double coveragePinstTinstAllPotUses;

	private static double coveragePalTalAllPotUses;

	private static double coveragePinstTalAllPotUses;

	private static double coveragePalTinstAllPotUses;

	private static double weightFuncional;

	private static double weightAllNodes;

	private static double weightAllEdges;

	private static double weightAllUses;

	private static double weightAllPotUses;

	private static double functionalPiTi;

	private static double functionalPaTa;

	private static double functionalPiTa;

	private static double functionalPaTi;

	private static double structuralPiTi;

	private static double structuralPaTa;

	private static double structuralPiTa;

	private static double structuralPaTi;

	private static double programScore;

	private static double testScore;

	private static double totalScore;

	public static void evaluate(Evaluation avaliation)
			throws EvaluationException {
		try {
			initializeAttributes(avaliation);
			calculateScore();
			generateXMLFiles(avaliation);
			saveAvaliation(avaliation);
		} catch (Throwable e) {
			e.printStackTrace();
			throw new EvaluationException(e.getMessage(), e.getCause());
		}
	}

	private static void initializeAttributes(Evaluation avaliation) {
		initializeCoverages(avaliation);
		initializeWeights(avaliation);
	}

	private static void initializeCoverages(Evaluation avaliation) {
		initializePinstTinstCoverages(avaliation);
		initializePalTalCoverages(avaliation);
		initializePinstTalCoverages(avaliation);
		initializePalTinstCoverages(avaliation);
	}

	private static void initializePinstTinstCoverages(Evaluation avaliation) {

		initializePinstTinstFuncionalCoverage(avaliation);

		String path = DirControl.getPinstTinstReportsPath(avaliation
				.getAssignment())
				+ File.separator + "CriterionCoverage.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePinstTinstAllNodes = Double.parseDouble(values[1][3]) / 100;
		coveragePinstTinstAllEdges = Double.parseDouble(values[3][3]) / 100;
		coveragePinstTinstAllUses = Double.parseDouble(values[5][3]) / 100;
		coveragePinstTinstAllPotUses = Double.parseDouble(values[7][3]) / 100;

	}

	private static void initializePinstTinstFuncionalCoverage(
			Evaluation avaliation) {

		String path = DirControl.getPinstTinstReportsPath(avaliation
				.getAssignment())
				+ File.separator + "Funcional.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePinstTinstFuncional = Double.parseDouble(values[1][3]) / 100;

	}

	private static void initializePalTalCoverages(Evaluation avaliation) {

		initializePalTalFuncionalCoverage(avaliation);

		String path = DirControl.getPalTalReportsPath(avaliation
				.getAssignment(), avaliation.getStudent())
				+ File.separator + "CriterionCoverage.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePalTalAllNodes = Double.parseDouble(values[1][3]) / 100;
		coveragePalTalAllEdges = Double.parseDouble(values[3][3]) / 100;
		coveragePalTalAllUses = Double.parseDouble(values[5][3]) / 100;
		coveragePalTalAllPotUses = Double.parseDouble(values[7][3]) / 100;

	}

	private static void initializePalTalFuncionalCoverage(Evaluation avaliation) {

		String path = DirControl.getPalTalReportsPath(avaliation
				.getAssignment(), avaliation.getStudent())
				+ File.separator + "Funcional.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePalTalFuncional = Double.parseDouble(values[1][3]) / 100;

	}

	private static void initializePinstTalCoverages(Evaluation avaliation) {

		initializePinstTalFuncionalCoverage(avaliation);

		String path = DirControl.getPinstTalReportsPath(avaliation
				.getAssignment(), avaliation.getStudent())
				+ File.separator + "CriterionCoverage.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePinstTalAllNodes = Double.parseDouble(values[1][3]) / 100;
		coveragePinstTalAllEdges = Double.parseDouble(values[3][3]) / 100;
		coveragePinstTalAllUses = Double.parseDouble(values[5][3]) / 100;
		coveragePinstTalAllPotUses = Double.parseDouble(values[7][3]) / 100;

	}

	private static void initializePinstTalFuncionalCoverage(
			Evaluation avaliation) {

		String path = DirControl.getPinstTalReportsPath(avaliation
				.getAssignment(), avaliation.getStudent())
				+ File.separator + "Funcional.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePinstTalFuncional = Double.parseDouble(values[1][3]) / 100;

	}

	private static void initializePalTinstCoverages(Evaluation avaliation) {

		initializePalTinstFuncionalCoverage(avaliation);

		String path = DirControl.getPalTinstReportsPath(avaliation
				.getAssignment(), avaliation.getStudent())
				+ File.separator + "CriterionCoverage.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePalTinstAllNodes = Double.parseDouble(values[1][3]) / 100;
		coveragePalTinstAllEdges = Double.parseDouble(values[3][3]) / 100;
		coveragePalTinstAllUses = Double.parseDouble(values[5][3]) / 100;
		coveragePalTinstAllPotUses = Double.parseDouble(values[7][3]) / 100;

	}

	private static void initializePalTinstFuncionalCoverage(
			Evaluation avaliation) {

		String path = DirControl.getPalTinstReportsPath(avaliation
				.getAssignment(), avaliation.getStudent())
				+ File.separator + "Funcional.xml";

		File XMLFile = new File(path);

		String values[][] = XMLParser.parse(XMLFile);

		coveragePalTinstFuncional = Double.parseDouble(values[1][3]) / 100;

	}

	private static void initializeWeights(Evaluation avaliation) {
		weightFuncional = avaliation.getAssignment().getWeightFunctional();
		weightAllNodes = avaliation.getAssignment().getWeightAllNodes();
		weightAllEdges = avaliation.getAssignment().getWeightAllEdges();
		weightAllUses = avaliation.getAssignment().getWeightAllUses();
		weightAllPotUses = avaliation.getAssignment().getWeightAllPotUses();
	}

	private static void calculateScore() {

		functionalPiTi = calculateFunctionalPiTi();
		functionalPaTa = calculateFunctionalPaTa();
		functionalPiTa = calculateFunctionalPiTa();
		functionalPaTi = calculateFunctionalPaTi();
		structuralPiTi = calculateStructuralPiTi();
		structuralPaTa = calculateStructuralPaTa();
		structuralPiTa = calculateStructuralPiTa();
		structuralPaTi = calculateStructuralPaTi();
		
		programScore = (functionalPaTa + functionalPaTi) / 2;
		
		testScore = (functionalPiTa + structuralPaTa) / 2;
		
		if((structuralPaTa >= structuralPaTi) && (functionalPaTa >= functionalPaTi))
			testScore = 1;
		  
		totalScore = (programScore + testScore) / 2;

		/*
		 * coveragePinstTinst = calculatePinstTinst(); coveragePalTal =
		 * calculatePalTal(); coveragePinstTal = calculatePinstTal();
		 * coveragePalTinst = calculatePalTinst();
		 * 
		 * double ts1;
		 * 
		 * double ts2;
		 * 
		 * if(coveragePinstTinst > 0) ts1 = coveragePinstTal /
		 * coveragePinstTinst; else ts1 = 1;
		 * 
		 * if(ts1 > 1) ts1 = 1;
		 * 
		 * if(coveragePalTinst > 0) ts2 = coveragePalTal / coveragePalTinst;
		 * else ts2 = 1;
		 * 
		 * if(ts2 > 1) ts2 = 1;
		 * 
		 * testScore = (ts1 + ts2) / 2;
		 * 
		 * programScore = coveragePalTinstFuncional;
		 * 
		 * if(programScore > 1) programScore = 1;
		 */
		 

	}

	private static double calculateStructuralPaTi() {
		// TODO Auto-generated method stub
		return (coveragePalTinstAllNodes * weightAllNodes
				+ coveragePalTinstAllEdges * weightAllEdges
				+ coveragePalTinstAllUses * weightAllUses + coveragePalTinstAllPotUses
				* weightAllPotUses)
				/ (weightAllNodes + weightAllEdges + weightAllUses + weightAllPotUses);
	}

	private static double calculateStructuralPiTa() {
		// TODO Auto-generated method stub
		return (coveragePinstTalAllNodes * weightAllNodes
				+ coveragePinstTalAllEdges * weightAllEdges
				+ coveragePinstTalAllUses * weightAllUses + coveragePinstTalAllPotUses
				* weightAllPotUses)
				/ (weightAllNodes + weightAllEdges + weightAllUses + weightAllPotUses);
	}

	private static double calculateStructuralPaTa() {
		// TODO Auto-generated method stub
		return (coveragePalTalAllNodes * weightAllNodes
				+ coveragePalTalAllEdges * weightAllEdges
				+ coveragePalTalAllUses * weightAllUses + coveragePalTalAllPotUses
				* weightAllPotUses)
				/ (weightAllNodes + weightAllEdges + weightAllUses + weightAllPotUses);
	}

	private static double calculateStructuralPiTi() {
		return (coveragePinstTinstAllNodes * weightAllNodes
				+ coveragePinstTinstAllEdges * weightAllEdges
				+ coveragePinstTinstAllUses * weightAllUses + coveragePinstTinstAllPotUses
				* weightAllPotUses)
				/ (weightAllNodes + weightAllEdges + weightAllUses + weightAllPotUses);
	}

	private static double calculateFunctionalPaTi() {
		return coveragePalTinstFuncional;
	}

	private static double calculateFunctionalPiTa() {
		return coveragePinstTalFuncional;
	}

	private static double calculateFunctionalPaTa() {
		return coveragePalTalFuncional;
	}

	private static double calculateFunctionalPiTi() {
		return coveragePinstTinstFuncional;
	}

	private static void generateXMLFiles(Evaluation avaliation)
			throws FileNotFoundException {
		generateXMLGeneralCoverage(avaliation);
		generateXMLTotalCoverage(avaliation);
		generateXMLResultAvaliation(avaliation);
	}

	private static void generateXMLGeneralCoverage(Evaluation avaliation)
			throws FileNotFoundException {

		String values[][] = new String[6][5];
		values[0][0] = "Criterion";
		values[0][1] = "Pi-Ti";
		values[0][2] = "Pa-Ta";
		values[0][3] = "Pi-Ta";
		values[0][4] = "Pa-Ti";
		values[1][0] = "Functional";
		values[1][1] = String.valueOf(Math.round(coveragePinstTinstFuncional * 100, 2)) + "%";
		values[1][2] = String.valueOf(Math.round(coveragePalTalFuncional * 100, 2)) + "%";
		values[1][3] = String.valueOf(Math.round(coveragePinstTalFuncional * 100, 2)) + "%";
		values[1][4] = String.valueOf(Math.round(coveragePalTinstFuncional * 100, 2)) + "%";
		values[2][0] = "All-Nodes";
		values[2][1] = String.valueOf(Math.round(coveragePinstTinstAllNodes * 100, 2)) + "%";
		values[2][2] = String.valueOf(Math.round(coveragePalTalAllNodes * 100, 2)) + "%";
		values[2][3] = String.valueOf(Math.round(coveragePinstTalAllNodes * 100, 2)) + "%";
		values[2][4] = String.valueOf(Math.round(coveragePalTinstAllNodes * 100, 2)) + "%";
		values[3][0] = "All-Edges";
		values[3][1] = String.valueOf(Math.round(coveragePinstTinstAllEdges * 100, 2)) + "%";
		values[3][2] = String.valueOf(Math.round(coveragePalTalAllEdges * 100, 2)) + "%";
		values[3][3] = String.valueOf(Math.round(coveragePinstTalAllEdges * 100, 2)) + "%";
		values[3][4] = String.valueOf(Math.round(coveragePalTinstAllEdges * 100, 2)) + "%";
		values[4][0] = "All-Uses";
		values[4][1] = String.valueOf(Math.round(coveragePinstTinstAllUses * 100, 2)) + "%";
		values[4][2] = String.valueOf(Math.round(coveragePalTalAllUses * 100, 2)) + "%";
		values[4][3] = String.valueOf(Math.round(coveragePinstTalAllUses * 100, 2)) + "%";
		values[4][4] = String.valueOf(Math.round(coveragePalTinstAllUses * 100, 2)) + "%";
		values[5][0] = "All-Pot-Uses";
		values[5][1] = String.valueOf(Math.round(coveragePinstTinstAllPotUses * 100, 2)) + "%";
		values[5][2] = String.valueOf(Math.round(coveragePalTalAllPotUses * 100, 2)) + "%";
		values[5][3] = String.valueOf(Math.round(coveragePinstTalAllPotUses * 100, 2)) + "%";
		values[5][4] = String.valueOf(Math.round(coveragePalTinstAllPotUses * 100, 2)) + "%";

		String root = "GeneralCoverage";

		String path = DirControl.getUserReportsPath(avaliation.getAssignment(),
				avaliation.getStudent())
				+ File.separator + "GeneralCoverage.xml";

		XMLParser.generateXML(root, values, path);

	}

	private static void generateXMLTotalCoverage(Evaluation avaliation)
			throws FileNotFoundException {

		String values[][] = new String[5][2];
		values[0][0] = "Executions";
		values[1][0] = "Instructor's Program - Instructor's Test Set";
		values[2][0] = "Student's Program - Student's Test Set";
		values[3][0] = "Instructor's Program - Student's Test Set";
		values[4][0] = "Student's Program - Instructor's Test Set";
		values[0][1] = "Coverage";
		values[1][1] = String.valueOf(Math.round(structuralPiTi * 100, 2))
				+ "%";
		values[2][1] = String.valueOf(Math.round(structuralPaTa * 100, 2))
				+ "%";
		values[3][1] = String.valueOf(Math.round(structuralPiTa * 100, 2))
				+ "%";
		values[4][1] = String.valueOf(Math.round(structuralPaTi * 100, 2))
				+ "%";

		String root = "TotalCoverage";

		String path = DirControl.getUserReportsPath(avaliation.getAssignment(),
				avaliation.getStudent())
				+ File.separator + "TotalCoverage.xml";

		XMLParser.generateXML(root, values, path);

	}

	private static void generateXMLResultAvaliation(Evaluation avaliation)
			throws FileNotFoundException {

		String values[][] = new String[3][2];
		values[0][0] = "Result";
		values[1][0] = "Program Accuracy";
		values[2][0] = "Test Set Quality";
		values[0][1] = "Score";
		values[1][1] = String.valueOf(Math.round(programScore * 100, 2)) + "%";
		values[2][1] = String.valueOf(Math.round(testScore * 100, 2)) + "%";

		String root = "EvaluationResult";

		String path = DirControl.getUserReportsPath(avaliation.getAssignment(),
				avaliation.getStudent())
				+ File.separator + "ResultAvaliation.xml";

		XMLParser.generateXML(root, values, path);

	}

	private static void saveAvaliation(Evaluation avaliation) {
		avaliation.setSubmissionDate(new Date());
		avaliation.setScore(Math.round(totalScore * 100, 2));
		EvaluationDAO.update(avaliation);
	}

}
